## 前言
**本项目总体上资源参考雷思磊老师的《自己动手写CPU》，在此向雷老师致敬。**

该项目本为学校课程要求，但就我校学生来说难度较大，加之对硬件感兴趣学生较少，
导致完成量较少，故此公布自己验收后的源码，给后续同学做一个参考。

由于本学校对学生要求难度还不是很高，仅要求实现MIPS的32条简单指令。

主要有以下几类：
1. 逻辑操作指令： and、andi、or、ori、xor、xori、nor、lui
2. 移位操作指令： sll、sllv、sra、srav、srl、srlv
3. 算数操作指令： add、addi、addiu、addu、sub、subu、slt、slti、sltiu、sltu
4. 转移操作指令： j、jr、jal、beq、bne
5. 加载操作指令： lw、sw

具体指令被内容参照文件`MIPS32条指令.pdf`

##主要功能模块
由于只需要实现32条指令，其中还不包括“乘法“、“除法”等复杂的运算指令，故只需要基本模块即可实现要求。

模块连接图参照`openmips模块连接关系图.png`。

在此只介绍主要功能模块，if_id、id_ex、ex_mem、mem_wb模块只起两个模块之间的传值
作用，故此不做介绍。
### PC
也即程序计数器，对应文件为`pc_reg.v`，主要实现的细节很简单：

#### 输入：
1. `rst`为重置输入，rst使能时禁止当前重置当前的程序计数器，芯片使能停止。
2. `branch_flag_i`、`branch_target_address_i`在转移指令时才会使用，使能时
将程序计数器的值置为目标地址，branch_flag_i为使能标志，branch_target_address_i为目标地址。
#### 输出：
1. `pc`为指令地址，输出至rom中取值。
2. `ce`为芯片使能。

### ROM
根据PC模块传入的地址取得目标指令，并送入译码模块进行译码。
#### 输入：
1. `addr`为pc传进来的要执行的指令的地址。
#### 输出：
1. `inst`为取到的指令（32位）。

### ID
众所周知为译码模块，对取得的指令进行分析。
#### 输入：
1. `pc_i` 从pc模块传入的指令地址，在移动指令中才会用到，根据目前的指令地址，进行操作得出新指令。
2. `inst_i`为取到的指令。
3. `ex_aluop_i` 为执行模块执行的运算类型
4. `ex_wreg_i` 执行模块执行指令是否要写寄存器
5. `ex_wdata_i` 执行模块执行指令要写寄存器的值
6. `ex_wd_i`执行模块要执行指令要写寄存器的地址
7. `mem_wreg_i` 回写模块执行指令是否要写寄存器
8. `mem_wdata_i` 回写模块执行指令要写寄存器的值
9. `mem_wd_i`回写模块要执行指令要写寄存器的地址
10. `reg1_data_i` 从寄存器中取得的reg1对应的值
11. `reg2_data_i` 从寄存器中取得的reg2对应的值 
#### 输出：
1. `reg1_read_o`为是否要读寄存器reg1
2. `reg2_read_o`为是否要读寄存器reg2
3. `reg1_addr_o`为读取reg1的地址
4. `reg2_read_o`为读取reg2的地址
5. `aluop_o`为运算类型
6. `alusel_o`为运算子类型
7. `reg1_o`读取到的寄存器reg1的值
8. `reg2_o`读取到的寄存器reg1的值
9. `wd_o`为是否要写寄存器的判断变量
10. `wreg_o`
11. `inst_o`指令
12. `branch_flag_o`上文提到的，只有在转移指令执行时才会用到，标识变量
13. `branch_target_address_o`目标转移地址
14. `link_addr_o`
